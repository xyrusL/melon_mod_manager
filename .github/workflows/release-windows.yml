name: Release Windows

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Existing git tag to release (example: v1.0.0-beta.1)'
        required: true
        type: string

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.tag_name || github.ref }}

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable
          cache: true

      - name: Resolve App Version
        id: meta
        shell: pwsh
        run: |
          $pubspecVersion = (Select-String -Path pubspec.yaml -Pattern '^version:\s*(.+)$').Matches[0].Groups[1].Value.Trim()
          $appVersion = $pubspecVersion.Split('+')[0]
          $dispatchTag = "${{ github.event_name == 'workflow_dispatch' && inputs.tag_name || '' }}"
          if (![string]::IsNullOrWhiteSpace($dispatchTag)) {
            $tagName = $dispatchTag
          } else {
            $tagName = "${{ github.ref_name }}"
          }
          if ([string]::IsNullOrWhiteSpace($tagName)) {
            $tagName = "v$appVersion"
          }
          $expectedTag = "v$appVersion"
          if ($tagName -ne $expectedTag) {
            throw "Tag/version mismatch. Tag is '$tagName' but pubspec.yaml is '$expectedTag'."
          }
          $isPreRelease = if ($appVersion.Contains('-')) { "true" } else { "false" }
          "app_version=$appVersion" >> $env:GITHUB_OUTPUT
          "tag_name=$tagName" >> $env:GITHUB_OUTPUT
          "is_prerelease=$isPreRelease" >> $env:GITHUB_OUTPUT

      - name: Install Dependencies
        run: flutter pub get

      - name: Analyze
        run: flutter analyze

      - name: Test
        run: flutter test

      - name: Build Windows Release
        run: flutter build windows --release

      - name: Prepare Code Signing Certificate
        id: sign_cert
        shell: pwsh
        run: |
          $pfxBase64 = "${{ secrets.WINDOWS_SIGN_PFX_BASE64 }}"
          $pfxPassword = "${{ secrets.WINDOWS_SIGN_PFX_PASSWORD }}"
          $hasSigning = -not [string]::IsNullOrWhiteSpace($pfxBase64) -and -not [string]::IsNullOrWhiteSpace($pfxPassword)

          if (-not $hasSigning) {
            "signing_enabled=false" >> $env:GITHUB_OUTPUT
            "cert_path=" >> $env:GITHUB_OUTPUT
            Write-Host "Code signing not configured. Continuing unsigned."
            exit 0
          }

          $certPath = Join-Path $env:RUNNER_TEMP "windows_codesign.pfx"
          [System.IO.File]::WriteAllBytes(
            $certPath,
            [System.Convert]::FromBase64String($pfxBase64)
          )
          "signing_enabled=true" >> $env:GITHUB_OUTPUT
          "cert_path=$certPath" >> $env:GITHUB_OUTPUT

      - name: Sign App Executable
        if: ${{ steps.sign_cert.outputs.signing_enabled == 'true' }}
        shell: pwsh
        env:
          SIGN_PFX_PASSWORD: ${{ secrets.WINDOWS_SIGN_PFX_PASSWORD }}
        run: |
          $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe" |
            Sort-Object FullName -Descending |
            Select-Object -First 1
          if ($null -eq $signtool) {
            throw "signtool.exe not found on runner."
          }
          $appExe = "build\windows\x64\runner\Release\melon_mod_manager.exe"
          if (!(Test-Path $appExe)) {
            throw "App executable not found at $appExe"
          }
          & $signtool.FullName sign /f "${{ steps.sign_cert.outputs.cert_path }}" /p "$env:SIGN_PFX_PASSWORD" /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 $appExe
          if ($LASTEXITCODE -ne 0) {
            throw "signtool failed while signing app executable."
          }
          & $signtool.FullName verify /pa $appExe
          if ($LASTEXITCODE -ne 0) {
            throw "signtool verification failed for app executable."
          }

      - name: Create Portable Zip
        id: portable
        shell: pwsh
        run: |
          $releaseDir = "build\windows\x64\runner\Release"
          if (!(Test-Path $releaseDir)) {
            throw "Windows release output not found at $releaseDir"
          }
          $zipName = "melon_mod_manager_windows_portable.zip"
          if (Test-Path $zipName) { Remove-Item $zipName -Force }
          Compress-Archive -Path "$releaseDir\*" -DestinationPath $zipName
          "portable_zip=$zipName" >> $env:GITHUB_OUTPUT

      - name: Install Inno Setup
        shell: pwsh
        run: choco install innosetup -y --no-progress

      - name: Build Installer
        id: installer
        shell: pwsh
        run: |
          $appVersion = "${{ steps.meta.outputs.app_version }}"
          $numericVersion = ($appVersion -replace '-.*$','')
          $parts = $numericVersion.Split('.')
          while ($parts.Length -lt 4) { $parts += "0" }
          $versionInfo = "$($parts[0]).$($parts[1]).$($parts[2]).$($parts[3])"
          $outputBase = "MelonModManager-Win64-Setup-$appVersion"
          $iscc = "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe"
          if (!(Test-Path $iscc)) {
            throw "ISCC not found at $iscc"
          }
          & $iscc "windows\installer\melon_mod_setup.iss" "/DMyAppVersion=$appVersion" "/DMyOutputBaseFilename=$outputBase" "/DMyVersionInfoVersion=$versionInfo"
          if ($LASTEXITCODE -ne 0) {
            throw "Inno Setup build failed with code $LASTEXITCODE"
          }
          $installerFile = Get-ChildItem -Path "windows\installer" -Filter "$outputBase*.exe" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if ($null -eq $installerFile) {
            throw "Installer not found in windows\\installer for base $outputBase"
          }
          $installerPath = $installerFile.FullName.Replace('\', '/')
          "installer_exe=$installerPath" >> $env:GITHUB_OUTPUT

      - name: Sign Installer Executable
        if: ${{ steps.sign_cert.outputs.signing_enabled == 'true' }}
        shell: pwsh
        env:
          SIGN_PFX_PASSWORD: ${{ secrets.WINDOWS_SIGN_PFX_PASSWORD }}
        run: |
          $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe" |
            Sort-Object FullName -Descending |
            Select-Object -First 1
          if ($null -eq $signtool) {
            throw "signtool.exe not found on runner."
          }
          $installer = "${{ steps.installer.outputs.installer_exe }}"
          if (!(Test-Path $installer)) {
            throw "Installer executable not found at $installer"
          }
          & $signtool.FullName sign /f "${{ steps.sign_cert.outputs.cert_path }}" /p "$env:SIGN_PFX_PASSWORD" /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 $installer
          if ($LASTEXITCODE -ne 0) {
            throw "signtool failed while signing installer executable."
          }
          & $signtool.FullName verify /pa $installer
          if ($LASTEXITCODE -ne 0) {
            throw "signtool verification failed for installer executable."
          }

      - name: Verify Release Files
        shell: pwsh
        run: |
          $portable = "${{ steps.portable.outputs.portable_zip }}"
          $installer = "${{ steps.installer.outputs.installer_exe }}"
          if (!(Test-Path $portable)) {
            throw "Portable zip missing: $portable"
          }
          if (!(Test-Path $installer)) {
            throw "Installer exe missing: $installer"
          }
          Write-Host "Portable: $portable"
          Write-Host "Installer: $installer"

      - name: Generate SHA256 Checksums
        id: checksums
        shell: pwsh
        run: |
          $portable = "${{ steps.portable.outputs.portable_zip }}"
          $installer = "${{ steps.installer.outputs.installer_exe }}"
          $checksumFile = "SHA256SUMS.txt"
          if (Test-Path $checksumFile) { Remove-Item $checksumFile -Force }

          $portableHash = (Get-FileHash -Path $portable -Algorithm SHA256).Hash.ToLower()
          $portableName = [System.IO.Path]::GetFileName($portable)
          "$portableHash  $portableName" | Out-File -FilePath $checksumFile -Encoding utf8

          $installerHash = (Get-FileHash -Path $installer -Algorithm SHA256).Hash.ToLower()
          $installerName = [System.IO.Path]::GetFileName($installer)
          "$installerHash  $installerName" | Out-File -FilePath $checksumFile -Encoding utf8 -Append

          $checksumPath = (Resolve-Path $checksumFile).Path.Replace('\', '/')
          "checksums_file=$checksumPath" >> $env:GITHUB_OUTPUT

      - name: Remove Legacy Release Assets
        shell: pwsh
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          $tag = "${{ steps.meta.outputs.tag_name }}"
          $currentPortable = [System.IO.Path]::GetFileName("${{ steps.portable.outputs.portable_zip }}")
          $currentInstaller = [System.IO.Path]::GetFileName("${{ steps.installer.outputs.installer_exe }}")
          $currentChecksums = [System.IO.Path]::GetFileName("${{ steps.checksums.outputs.checksums_file }}")

          $legacyPatterns = @(
            "melon_mod_setup_*.exe",
            "melon_mod_windows_*_portable.zip",
            "melon_mod_windows_portable.zip"
          )

          $assets = gh release view $tag --json assets --jq ".assets[].name"
          if ([string]::IsNullOrWhiteSpace($assets)) {
            Write-Host "No existing assets to clean."
            exit 0
          }

          $assetList = $assets -split "`r?`n" | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }
          foreach ($asset in $assetList) {
            if ($asset -eq $currentPortable -or $asset -eq $currentInstaller -or $asset -eq $currentChecksums) {
              continue
            }

            $isLegacy = $false
            foreach ($pattern in $legacyPatterns) {
              if ($asset -like $pattern) {
                $isLegacy = $true
                break
              }
            }

            if ($isLegacy) {
              Write-Host "Deleting legacy asset: $asset"
              gh release delete-asset $tag $asset --yes
            }
          }

      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.meta.outputs.tag_name }}
          name: Melon Mod Manager ${{ steps.meta.outputs.app_version }}
          prerelease: ${{ steps.meta.outputs.is_prerelease }}
          body: |
            Windows release artifacts:
            - Installer (`.exe`) for normal users
            - Portable (`.zip`) for advanced users
            - SHA256 checksums (`SHA256SUMS.txt`) for integrity verification

            Notes:
            - Use the installer for easiest setup.
            - Portable zip can run without installation.
            - You can verify downloaded files against `SHA256SUMS.txt`.
          generate_release_notes: true
          overwrite_files: true
          files: |
            ${{ steps.portable.outputs.portable_zip }}
            ${{ steps.installer.outputs.installer_exe }}
            ${{ steps.checksums.outputs.checksums_file }}
